---
layout: ../../layouts/research.astro
id: "boids-exploring-bird-swarming"
title: "Boids: Exploring Bird Swarming"
authors: "Ian Lim"
publishedDate: "2024-09-15"
excerpt: "As we approach a future where regional affluence is soaring, yet the headcounts of console-based operators continue to drop, one fact is without question: cognitive saturation is inevitable."
readTime: "8 min read"
category: "AI & Neuroscience"

---

As part of our ongoing efforts in developing the C3 platform, we had to generate tracks—paths for drones to follow. At first, these were simple, rigid patterns: straight lines, circles, maybe a boxy loop. Sure they worked, but they felt dull & mechanical—no flow, no life.

And that’s when Aloysius came up with a superb idea: “What if we implemented the Boids Algorithm?”. 

Now you might be thinking, “why are we complicating things when our tracks are already functional?”. Sure, our original tracks were functional. But Boids gave us a chance to stress test the system and simulate more natural, dynamic movement—something that fits perfectly with the direction we’re heading.

## What is Boids Algorithm?

In case you don’t know what Boids Algorithm is, Boids is a simulation that mimics the flocking behavior seen in birds or the schooling behavior of fish. Instead of following simple, predetermined paths, each "boid" (a term for a member of the flock) interacts with its neighbors and adjusts its own movement based on a few simple rules—alignment, separation, and cohesion. This creates an organic flocking behavioural movement that feels natural and unpredictable, with each boid responding to its surroundings in real time.


## How does it Work?

To keep it simple, the Boids Algorithm is made up of just three simple rules. But when you apply these rules to a group of independent agents (the boids), the result is surprisingly complex and realistic group behavior - like how birds flock or fish school in nature.

### Three main rules:


Just like a real bird or fish, even though each boid technically has access to the whole scene, it only reacts to nearby flockmates—those boids that are within a certain distance and within its field of view. If another boid is too far away or outside that range, it’s ignored. This limited awareness makes the behavior feel more natural, like birds only reacting to the ones they can actually see around them.



## Implementing the Boids Algorithm in 3D

We implemented the Boids Algorithm in a 3D environment using Python, drawing inspiration from the work of Ercan Gerçek, who experimented with optimizing a 3D Boids Simulation. 

In the typical default implementation of Boids Algorithm, he observed that the typical implementation of the Boids Algorithm—where each boid checks every other entity—quickly becomes computationally expensive as the number of boids increases.

Hence, to tackle this, he introduced spatial partitioning through a grid system to speed up proximity checks. The world is divided into a 3D array of cells (or “grids”), and each boid is slotted into a cell based on its position. When a boid moves, it’s simply removed from its current grid and added to a new one. This made neighbor searches extremely efficient because you only need to check nearby grids instead of the entire scene.

We adopted this same strategy in our own 3D Boids Simulation Engine to improve performance, making our simulation more efficient and scalable, especially as we are looking to have about 10,000 flocks in the system.

On a side note, Ercan also explored the possibility of using more advanced spatial structures like octrees, which can offer better memory efficiency—especially for large-scale simulations. While we opted for the simplicity and speed of a grid system for now, octrees are definitely something we’re considering for future iterations as we continue to scale and optimize our simulation.


## Integration with the C3 Platform

However, implementing the Boids Algorithm wasn’t our only challenge. Our simulation ran in a Cartesian coordinate system (i.e., x, y, z space), but our drones need to move in the real world, using geodetic coordinates (latitude, longitude, and altitude).

This meant we had to convert our simulated positions into real-world geospatial coordinates, allowing the boids' movement to be projected meaningfully onto actual map data. 

So to do that we used the Haversine Formula to help with this. While it’s traditionally used to calculate the great-circle distance between two points on a sphere, we flipped the idea around a bit—by treating our x and y offsets (in meters) as distances from a known reference point (with a known lat/lon), we used Haversine-based calculations to estimate the corresponding latitude and longitude of each boid in the real world.

Here’s the basic form of the Haversine Formula we used:

Where:
* d is the distance between the two points (along the surface of the sphere).
* R is the radius of the sphere (in this case, the radius of the Earth).
* lat1​ and lat2​ are the latitudes of the two points.
* Δlat is the difference between the latitudes.
* Δlon is the difference between the longitudes.
* atan2 is a special function that computes the arctangent of the quotient of its arguments.

For our boids, we applied this concept in reverse to determine how far an (x, y) offset would shift the boid’s lat/lon, relative to the reference origin point.
As for altitude—it was more straightforward. We simply took the z-value from the Cartesian space and added it to the base altitude of our origin point.

While this approach gave us reasonably accurate results for local areas (like within Singapore), we’re aware that there are more precise geodetic systems out there. In the future, we’re planning to explore libraries like pyproj, geopy, or even converting via ECEF (Earth-Centered, Earth-Fixed) and LLA (Latitude, Longitude, Altitude) models to make our coordinate transformation more robust and scalable for larger regions or higher-accuracy requirements.

## Conclusion

To wrap things up, integrating the Boids Algorithm into our C3 platform gave our project not just a fresh perspective, but a real glimpse into what’s possible moving forward. It made our drone behavior feel more life-like and responsive, and it helped us push the boundaries of what our system could handle with more natural, coordinated movement.

But more than that, it laid the groundwork for what’s next. The implementation of Boids Algorithm set the stage for us to dive deeper into swarming algorithms and really start exploring how groups of drones can interact, adapt, and move as one. Boids was our solid first step, and it’s exciting about where this will go from here.
